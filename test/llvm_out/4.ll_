define i32 @fib(i32) {
    %2 = alloca i32, align 4 ;申请缓存区，得到指针i32* %2
    %3 = alloca i32, align 4 ;申请缓存区，得到指针i32* %3
    store i32 %0 , i32* %3, align 4 ;将形参 %0 的值放入内存
    %4 = load i32,i32* %3, align 4  ;读取形参到%4
    %5 = icmp eq i32 %4, 0  ; 与0比较是否相等
    br i1 %5, label %br1, label %br2 ;相等则转到标签br1，否则转到br2

;%2,%3申请在内存区；%3指的是形参n；每次使用需先读取传入寄存器；改值时要写回内存；

    br1:
    ret i32 0   ; n等于0 ，返回0

    br2:
    %6 = load i32,i32* %3, align 4   ;把形参读入寄存器%6
    %7 = icmp eq i32 %6, 1  ;与1比较
    br i1 %7, label %br3, label %br4

    br3:
    ret i32 1   ; n等于1，返回1

    br4:
    %8 = load i32, i32* %3, align 4  ;读入寄存器；
    %9 = sub nsw i32 %8, 1          ;t3
    %10 = call i32 @fib(i32 %9) ; 求fib(n-1)，t4
    %11 = load i32, i32* %3, align 4
    %12 = sub nsw i32 %11, 2      ;t5
    %13 = call i32 @fib(i32 %12) ; 求fib(n-2),t6
    %14 = add nsw i32 %10,%13   ;t7
    ret i32 %14 ; 返回结果
}

define i32 @main() {
    %1 = alloca i32, align 4 ; 为局部变量 x 分配栈空间
    %2 = alloca i32, align 4 ; 为局部变量 i 分配栈空间
    store i32 0, i32* %1, align 4 ; x = 0
    store i32 1, i32* %2, align 4 ; i = 1
    br label %br1               ; ? ? ?

    br1:
    %3 = load i32,i32* %2, align 4 ; 读取 i 的值
    %4 = icmp slt i32 %3, 8 ; 和8比较，看是否跳出循环
    br i1 %4,label %br2, label %br3 ; 判断成立，跳转到br2，否则跳转到br3

    br2:
    %5 = load i32, i32* %2, align 4 ; 读取 i 的值
    %6 = call i32 @fib(i32 %5)  ; 调用函数fib(i)，获得结果
    %7 = load i32 ,i32* %1, align 4 ; 读取 x 的值
    %8 = add nsw i32 %6, %7 ; x += fib(i)
    store i32 %8, i32* %1, align 4 ; 将结果存入 x 中
    %9 = add nsw i32 %5, 1 ; i = i + 1
    store i32 %9,i32* %2, align 4 ; 将结果存入 i 中
    br label %br1 ; 跳转到循环起始处继续执行

    br3:
    %10 = load i32,i32* %1, align 4 ; 读取 i 的值
    ret i32 %10 ; 返回 i 的值
}
